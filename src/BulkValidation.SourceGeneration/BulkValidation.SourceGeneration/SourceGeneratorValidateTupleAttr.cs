using System.Collections.Immutable;
using System.Linq;
using System.Text;
using BulkValidation.SourceGeneration.Models;
using BulkValidation.SourceGeneration.Static;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BulkValidation.SourceGeneration;

[Generator]
public class SourceGeneratorValidateTupleAttr : IIncrementalGenerator
{
    //Depends on ExistenceRule
    private readonly ImmutableArray<(string @namespace, string shortcut, ArgumentMetadata[] additionalArgs)> _baseRules =
        ImmutableArray.Create(("BulkValidation.Core.Rules.ExistenceRule", "Exists", new []
        {
            new ArgumentMetadata("BulkValidation.Core.Enums.Quantifier", "quantifier", "BulkValidation.Core.Enums.Quantifier.Any")
        }));
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var optionsProvider = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) =>
            {
                provider.GlobalOptions
                    .TryGetValue("build_property.RootNamespace".ToLowerInvariant(), 
                        out var rootNamespace);
                
                return rootNamespace!;
            });

        var propWithValidateAttr = GetPropertiesWithValidateTupleAttribute(context)
            .Combine(optionsProvider);
        
        context.RegisterSourceOutput(propWithValidateAttr, GenForValidateTuple);
    }

    private void GenForValidateTuple(SourceProductionContext context, 
        (ImmutableArray<IPropertySymbol?> left, string right) tuple)
    {
        var (properties, rootNamespace) = tuple;

        if (properties.IsDefaultOrEmpty)
            return;

        var sb = new StringBuilder();
        sb.AppendLine($$"""
                        // <auto-generated />
                        using System;
                        using System.Linq.Expressions;
                        using BulkValidation.Core.Models;
                        using BulkValidation.Core.Interfaces;

                        namespace {{rootNamespace}}
                        {
                            public static partial class ValidationPlanShortCutsForValidateTuple
                            {
                        """);

        var tupleProperties = properties
            .Where(x => x != null)
            .Select(x => x!)
            .GroupBy(p => new
            {
                TupleKey = GetValidateTupleKey(p),
                ContainingType = p.ContainingType
            });


        foreach (var tupleProp in tupleProperties)
        {
            var association = tupleProp.Key.TupleKey;
            var entitySymbol = tupleProp.Key.ContainingType;
            var propertiesSymbols = tupleProp.ToArray();
            if (association == null || entitySymbol == null || propertiesSymbols.Length <= 1) continue;
            
            var shortClassName = entitySymbol.Name;
            var longClassName = entitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            StringBuilder keyTypeStr = new StringBuilder("(");

            foreach (var propertySymbol in propertiesSymbols)
                keyTypeStr.Append($"{propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}, ");
            
            keyTypeStr.Length -= 2;
            keyTypeStr.Append(")");
            
            foreach (var rule in _baseRules)
            {
                var kv = RuleKeyValue.GenerateTupleKeyValue(entitySymbol, propertiesSymbols, "keyValue");
                var additionalArgs = string.Join(", ", rule.additionalArgs.Select(x => 
                {
                    var i = x.DefaultValue == null ? "" : $" = {x.DefaultValue}";
                    return $"{x.Type} {x.Name} {i}"; 
                }));
                if (!string.IsNullOrWhiteSpace(additionalArgs))
                    additionalArgs = ", " + additionalArgs;
                
                sb.AppendLine($$"""
                                public static IValidationPlan Validate{{shortClassName}}{{rule.shortcut}}{{association}}(
                                    this IValidationPlan plan, {{keyTypeStr}} value {{additionalArgs}})
                                {
                                    {{kv}}
                                    keyValue.WithValue(value);
                                    plan.Add(new global::{{rule.@namespace}}<{{longClassName}}>(keyValue));
                                    return plan;
                                }
                                """);
            }
        }
        sb.AppendLine("}}");
        context.AddSource("ValidationPlanTupleExtension.g.cs", sb.ToString());
    }

    private IncrementalValueProvider<ImmutableArray<IPropertySymbol?>> GetPropertiesWithValidateTupleAttribute(
        IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "BulkValidation.Core.Attributes.ValidateTupleAttribute",
                (node, _) => node is PropertyDeclarationSyntax,
                (ctx, _) => ctx.TargetSymbol as IPropertySymbol)
            .Where(x => x != null)
            .Collect();
    }
    
    private static string? GetValidateTupleKey(IPropertySymbol? property)
    {
        if (property == null) return null;
        var attr = property.GetAttributes()
            .FirstOrDefault(a =>
                a.AttributeClass?.ToDisplayString() ==
                "BulkValidation.Core.Attributes.ValidateTupleAttribute");

        if (attr == null)
            return null;

        // [ValidateTuple("PK")]
        if (attr.ConstructorArguments.Length > 0)
            return attr.ConstructorArguments[0].Value as string;

        return null;
    }
}