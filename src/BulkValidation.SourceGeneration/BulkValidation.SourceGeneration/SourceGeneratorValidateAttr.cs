using System.Collections.Immutable;
using System.Linq;
using System.Text;
using BulkValidation.SourceGeneration.Models;
using BulkValidation.SourceGeneration.Static;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BulkValidation.SourceGeneration;

[Generator]
public class SourceGeneratorValidateAttr : IIncrementalGenerator
{
    //Depends on ExistenceRule
    private readonly ImmutableArray<(string @namespace, string shortcut, ArgumentMetadata[] additionalArgs)> _baseRules =
        ImmutableArray.Create(("BulkValidation.Core.Rules.ExistenceRule", "Exists", new []
        {
            new ArgumentMetadata("BulkValidation.Core.Enums.Quantifier", "quantifier", "BulkValidation.Core.Enums.Quantifier.Any")
        }));
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var optionsProvider = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) =>
            {
                provider.GlobalOptions
                    .TryGetValue("build_property.RootNamespace".ToLowerInvariant(), 
                        out var rootNamespace);
                
                return rootNamespace!;
            });

        var propWithValidateAttr = GetPropertiesWithValidateAttribute(context)
            .Combine(optionsProvider);
        
        context.RegisterSourceOutput(propWithValidateAttr, GenForValidate);
    }

    private void GenForValidate(SourceProductionContext context, 
        (ImmutableArray<IPropertySymbol?> left, string right) tuple)
    {
        var (properties, rootNamespace) = tuple;

        if (properties.IsDefaultOrEmpty)
            return;

        var sb = new StringBuilder();
        sb.AppendLine($$"""
                        // <auto-generated />
                        using System;
                        using System.Collections.Generic;
                        using System.Linq.Expressions;
                        using BulkValidation.Core.Models;
                        using BulkValidation.Core.Interfaces;

                        namespace {{rootNamespace}}
                        {
                            public static partial class ValidationPlanShortCutsForValidate
                            {
                        """);

        foreach (var propertySymbol in properties)
        {
            if (propertySymbol == null) continue;
            
            var entitySymbol = propertySymbol.ContainingType;

            if (entitySymbol == null) continue;
            var shortClassName = entitySymbol.Name;
            var longClassName = entitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var shortPropertyName = propertySymbol.Name[..1].ToUpperInvariant() + propertySymbol.Name[1..];
            var keyTypeStr = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            
            foreach (var rule in _baseRules)
            {
                var kv = RuleKeyValue.GenerateKeyValue(entitySymbol, propertySymbol, "keyValue");
                var kvs = RuleKeyValue.GenerateKeyValues(entitySymbol, propertySymbol, "keyValues");
                var additionalArgs = string.Join(", ", rule.additionalArgs.Select(x => 
                {
                    var i = x.DefaultValue == null ? "" : $" = {x.DefaultValue}";
                    return $"{x.Type} {x.Name} {i}"; 
                }));
                if (!string.IsNullOrWhiteSpace(additionalArgs))
                    additionalArgs = ", " + additionalArgs;
                
                sb.AppendLine($$"""
                                public static IValidationPlan Validate{{shortClassName}}{{rule.shortcut}}{{shortPropertyName}}(
                                    this IValidationPlan plan, {{keyTypeStr}} value {{additionalArgs}})
                                {
                                    {{kv}}
                                    keyValue.WithValue(value);
                                    plan.Add(new global::{{rule.@namespace}}<{{longClassName}}>(keyValue));
                                    return plan;
                                }
                                """);
                sb.AppendLine($$"""
                                public static IValidationPlan Validate{{shortClassName}}{{rule.shortcut}}{{shortPropertyName}}(
                                    this IValidationPlan plan{{additionalArgs}}, params {{keyTypeStr}}[] values)
                                {
                                    {{kvs}}
                                    keyValues.WithValue(values);
                                    plan.Add(new global::{{rule.@namespace}}<{{longClassName}}>(keyValues));
                                    return plan;
                                }
                                """);
                sb.AppendLine($$"""
                                public static IValidationPlan Validate{{shortClassName}}{{rule.shortcut}}{{shortPropertyName}}(
                                    this IValidationPlan plan, IEnumerable<{{keyTypeStr}}> values{{additionalArgs}})
                                {
                                    {{kvs}}
                                    keyValues.WithValue(values);
                                    plan.Add(new global::{{rule.@namespace}}<{{longClassName}}>(keyValues));
                                    return plan;
                                }
                                """);
            }
        }
        sb.AppendLine("}}");
        context.AddSource("ValidationPlanExtension.g.cs", sb.ToString());
    }

    private IncrementalValueProvider<ImmutableArray<IPropertySymbol?>> GetPropertiesWithValidateAttribute(
        IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "BulkValidation.Core.Attributes.ValidateAttribute",
                (node, _) => node is PropertyDeclarationSyntax,
                (ctx, _) => ctx.TargetSymbol as IPropertySymbol)
            .Where(x => x != null)
            .Collect();
    }
}